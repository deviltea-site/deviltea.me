import{_ as n}from"./bx-anchor.025cc034.js";import{o as s,c as a,a as e,F as o,x as t,B as p}from"./vendor.f898a416.js";const c={title:"Type Challenges Notes - Medium 篇（一）",description:"練習作答 Type Challenges Medium 難度的第一部分",tags:["TypeScript","Type Challenges","筆記"],publishedDate:16208352e5},l=[{level:"2",content:'<a class="header-anchor" href="#%E5%89%8D%E8%A8%80"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> &#x524D;&#x8A00;'},{level:"2",content:'<a class="header-anchor" href="#%E6%9C%AC%E6%96%87"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> &#x672C;&#x6587;'},{level:"3",content:'<a class="header-anchor" href="#medium-1-~-xx"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> Medium 1 ~ XX'},{level:"4",content:'<a class="header-anchor" href="#get-return-type"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/2-medium-return-type/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Get Return Type</a>'},{level:"4",content:'<a class="header-anchor" href="#omit"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/3-medium-omit/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Omit</a>'},{level:"4",content:'<a class="header-anchor" href="#readonly-2"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/8-medium-readonly-2/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Readonly 2</a>'},{level:"4",content:'<a class="header-anchor" href="#deep-readonly"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/9-medium-deep-readonly/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Deep Readonly</a>'},{level:"4",content:'<a class="header-anchor" href="#tuple-to-union"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/10-medium-tuple-to-union/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Tuple to Union</a>'},{level:"4",content:'<a class="header-anchor" href="#chainable-options"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/12-medium-chainable-options/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Chainable Options</a>'},{level:"4",content:'<a class="header-anchor" href="#last-of-array"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/15-medium-last/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Last of Array</a>'},{level:"4",content:'<a class="header-anchor" href="#pop"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/16-medium-pop/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Pop</a>'},{level:"4",content:'<a class="header-anchor" href="#promise.all"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/20-medium-promise-all/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Promise.all</a>'},{level:"4",content:'<a class="header-anchor" href="#type-lookup"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> <a href="https://github.com/type-challenges/type-challenges/blob/master/questions/62-medium-type-lookup/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Type Lookup</a>'},{level:"2",content:'<a class="header-anchor" href="#%E5%BE%8C%E8%A8%98"><icon-bx-bx-anchor></icon-bx-bx-anchor></a> &#x5F8C;&#x8A18;'}],r={id:"%E5%89%8D%E8%A8%80"},k={class:"header-anchor",href:"#%E5%89%8D%E8%A8%80"},i=t(" 前言"),u=e("p",null,[t("接續上一篇 "),e("a",{href:"https://deviltea.me/posts/type-challenges",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Type Challenges Notes - Easy 篇"),t(" 後，這次繼續來作答 Medium 難度，由於這個難度的題目數量截至目前有 31 題，所以預計會分個三、四篇來撰寫，那就開始吧")],-1),d={id:"%E6%9C%AC%E6%96%87"},h={class:"header-anchor",href:"#%E6%9C%AC%E6%96%87"},y=t(" 本文"),b={id:"medium-1-~-xx"},m={class:"header-anchor",href:"#medium-1-~-xx"},g=t(" Medium 1 ~ XX"),x={id:"get-return-type"},f={class:"header-anchor",href:"#get-return-type"},T=t(),E=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/2-medium-return-type/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Get Return Type",-1),w=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">MyReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> infer <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">never</span>\n</code></pre></li><li>筆記：<br> 建立條件判斷並利用 <code>infer</code> 來進行返回型態推斷 <code>R</code>，符合條件判斷即返回 <code>R</code>，為配合所有 function 型別，定義參數為 <code>...args: any[]</code></li></ul>',1),R={id:"omit"},A={class:"header-anchor",href:"#omit"},M=t(),v=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/3-medium-omit/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Omit",-1),D=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">MyOmit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">as</span> <span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">K</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 這邊用到一個沒用過的關鍵字 <code>as</code>，可以看一下官方文件的<a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as" class="external-link" target="_blank" rel="noopener noreferrer">說明</a>，就我的感受上他比較像是可以將 Mapped Type 中的 key 在指定型態的過程中對型別再次轉換，像是答案中定義 key 的步驟 <ol><li>先定義 <code>P</code> 是 keyof <code>T</code></li><li>再約束 <code>P</code> 差集 <code>K</code><br> 最後 value 為 <code>T[P]</code></li></ol></li></ul>',1),P={id:"readonly-2"},_={class:"header-anchor",href:"#readonly-2"},q=t(),C=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/8-medium-readonly-2/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Readonly 2",-1),K=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">MyReadonly2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">as</span> <span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">K</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 一開始就先約束 <code>K extends keyof T</code>，且可以不提供 <code>K</code> 預設為 <code>keyof T</code>，接下來切成兩部分，第一部分是挑選成為 readonly 的部分，由於一開始我們就已約束 <code>K extends keyof T</code> 於是可以直接寫 <code>readonly [P in K]: T[P];</code>，再來就是類似 <code>Omit</code> 方法去挑選保持原狀的部分，最後將兩部分 <code>&amp;</code> 起來即可</li></ul>',1),U={id:"deep-readonly"},L={class:"header-anchor",href:"#deep-readonly"},O=t(),V=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/9-medium-deep-readonly/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Deep Readonly",-1),B=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span>\n  <span class="token operator">?</span> <span class="token constant">T</span>\n  <span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>\n  <span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 沒有錯啦！型別系統也可以有遞迴（汗，這題就是如果是巢狀型別叫要進去讓最後所有包含的屬性皆為 <code>readonly</code>，遞迴我們都知道有兩個重點，<code>自己呼叫自己</code>、<code>要有終止條件</code>，於是我們先決定出終止條件，<code>keyof T extends never</code> 判斷是否為有 key 要繼續遞迴下去，剩下就是自己呼叫自己的部分。</li></ul>',1),X={id:"tuple-to-union"},j={class:"header-anchor",href:"#tuple-to-union"},F=t(),G=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/10-medium-tuple-to-union/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Tuple to Union",-1),N=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">TupleToUnion<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span>\n</code></pre></li><li>筆記：<br> 首先 tuple 應是有序的陣列型態所以先約束 <code>T extends readonly unknown[]</code>，所以返回 <code>T[number]</code> 即可。</li></ul>',1),I={id:"chainable-options"},S={class:"header-anchor",href:"#chainable-options"},z=t(),H=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/12-medium-chainable-options/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Chainable Options",-1),J=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Chainable<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token generic-function"><span class="token function">option</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token constant">V</span><span class="token punctuation">)</span><span class="token operator">:</span> Chainable<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">V</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>\n  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 刷新觀念的一題，再次感嘆型別系統的靈活性！首先讓 <code>T</code> 預設為 <code>{}</code>，接著重點在於 <code>option</code> 此 method 的型別定義，我們定義他的 generic 為 <code>&lt;K extends string, V&gt;</code>，讓他去自動推斷參數 key 與 value 的型別，令其返回的型別為 <code>Chainable&lt;T &amp; { [P in K]: V }&gt;</code>，就是將目前的 <code>T</code> 與剛傳入的 <code>K</code>、<code>V</code> 組合起來；而 <code>get</code> 就是返回目前傳入的 <code>T</code>。</li></ul>',1),Q={id:"last-of-array"},W={class:"header-anchor",href:"#last-of-array"},Y=t(),Z=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/15-medium-last/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Last of Array",-1),$=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Last<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token string">&#39;length&#39;</span><span class="token punctuation">]</span><span class="token punctuation">]</span>\n</code></pre></li><li>筆記：<br> 若型別為 tuple (<code>readonly any[]</code>)，則 <code>Array[&#39;length&#39;]</code> 型別就會是具體的數字而不單只是 <code>number</code>，這個做法是利用擴展符號做出長度為 <code>T.length + 1</code> 的 tuple，再利用上述所說的 length 特性來取出最後的元素型別。</li></ul>',1),nn={id:"pop"},sn={class:"header-anchor",href:"#pop"},an=t(),en=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/16-medium-pop/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Pop",-1),on=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Pop<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token operator">...</span>infer <span class="token constant">R</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">never</span>\n</code></pre></li><li>筆記：<br> 這題利用擴展符號配合 <code>infer</code> 來推斷出排除最後一個元素後剩下部分 tuple。</li></ul>',1),tn={id:"promise.all"},pn={class:"header-anchor",href:"#promise.all"},cn=t(),ln=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/20-medium-promise-all/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Promise.all",-1),rn=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">PromiseAll</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>values<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span>\n  <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span>infer <span class="token constant">R</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span>\n</code></pre></li><li>筆記：<br> 這題卡住了一陣子，最後參考了他人的<a href="https://github.com/type-challenges/type-challenges/issues/211" class="external-link" target="_blank" rel="noopener noreferrer">解答</a>，仍然是似懂非懂，需要再做更深的理解。</li></ul>',1),kn={id:"type-lookup"},un={class:"header-anchor",href:"#type-lookup"},dn=t(),hn=e("a",{href:"https://github.com/type-challenges/type-challenges/blob/master/questions/62-medium-type-lookup/README.md",class:"external-link",target:"_blank",rel:"noopener noreferrer"},"Type Lookup",-1),yn=p('<ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">LookUp<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> <span class="token keyword">type</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span>\n<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span>\n</code></pre></li><li>筆記：<br> 先令 <code>T</code> 為 string，使 <code>T</code> 可為 Mapped Type 所用，接著定義一個 Mapped Type，<code>K</code> 於 <code>T</code> 之中，約束 <code>U</code> 需繼承 <code>{ type: T }</code>，此時已經將 <code>U</code> 的聯集分離了，最後再直接以 <code>[T]</code> 來返回分離後型別。</li></ul>',1),bn={id:"%E5%BE%8C%E8%A8%98"},mn={class:"header-anchor",href:"#%E5%BE%8C%E8%A8%98"},gn=t(" 後記"),xn=e("p",null,"進入到 Medium 的階段後，難度真的是大幅提升啊（汗，有很多的觀念有待釐清，還有一題日後再來補充。",-1);function fn(t,p){const c=n;return s(),a(o,null,[e("h2",r,[e("a",k,[e(c)]),i]),u,e("h2",d,[e("a",h,[e(c)]),y]),e("h3",b,[e("a",m,[e(c)]),g]),e("h4",x,[e("a",f,[e(c)]),T,E]),w,e("h4",R,[e("a",A,[e(c)]),M,v]),D,e("h4",P,[e("a",_,[e(c)]),q,C]),K,e("h4",U,[e("a",L,[e(c)]),O,V]),B,e("h4",X,[e("a",j,[e(c)]),F,G]),N,e("h4",I,[e("a",S,[e(c)]),z,H]),J,e("h4",Q,[e("a",W,[e(c)]),Y,Z]),$,e("h4",nn,[e("a",sn,[e(c)]),an,en]),on,e("h4",tn,[e("a",pn,[e(c)]),cn,ln]),rn,e("h4",kn,[e("a",un,[e(c)]),dn,hn]),yn,e("h2",bn,[e("a",mn,[e(c)]),gn]),xn],64)}const Tn={render:fn,__hmrId:"/home/runner/work/deviltea.me/deviltea.me/posts/type-challenges-2.md"},En=n=>({components:n,render:fn});export{Tn as VueComponent,En as VueComponentWith,c as attributes,l as toc};
