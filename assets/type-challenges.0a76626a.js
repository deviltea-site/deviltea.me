import{o as n,k as s,F as e,y as a,l as t,q as o}from"./vendor.574491cd.js";const p=a('<h1 id="h1-heading-8-)">h1 Heading 😎</h1><h2 id="h2-heading">h2 Heading</h2><h3 id="h3-heading">h3 Heading</h3><h4 id="h4-heading">h4 Heading</h4><h5 id="h5-heading">h5 Heading</h5><h6 id="h6-heading">h6 Heading</h6><h2 id="horizontal-rules">Horizontal Rules</h2><hr><hr><hr><h2 id="typographic-replacements">Typographic replacements</h2><p>Enable typographer option to see result.</p><p>© © ® ® ™ ™ § § ±</p><p>test… test… test… test?.. test!..</p><p>!!! ??? , – —</p><p>“Smartypants, double quotes” and ‘single quotes’</p><h2 id="emphasis">Emphasis</h2><p><strong>This is bold text</strong></p><p><strong>This is bold text</strong></p><p><em>This is italic text</em></p><p><em>This is italic text</em></p><p><s>Strikethrough</s></p><h2 id="blockquotes">Blockquotes</h2><blockquote><p>Blockquotes can also be nested…</p><blockquote><p>…by using additional greater-than signs right next to each other…</p><blockquote><p>…or with spaces between arrows.</p></blockquote></blockquote></blockquote><h2 id="lists">Lists</h2><p>Unordered</p><ul><li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li><li>Sub-lists are made by indenting 2 spaces: <ul><li>Marker character change forces new list start: <ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>Very easy!</li></ul><p>Ordered</p><ol><li><p>Lorem ipsum dolor sit amet</p></li><li><p>Consectetur adipiscing elit</p></li><li><p>Integer molestie lorem at massa</p></li><li><p>You can use sequential numbers…</p></li><li><p>…or keep all the numbers as <code>1.</code></p></li></ol><p>Start numbering with offset:</p><ol start="57"><li>foo</li><li>bar</li></ol><h2 id="code">Code</h2><p>Inline <code>code</code></p><p>Indented code</p>',34),l=t("pre",null,[t("code",{"v-pre":"true"},"// Some comments\nline 1 of code\nline 2 of code\nline 3 of code\n")],-1),c=t("p",null,"Block code “fences”",-1),r=t("pre",{class:"code-block language-plain"},[t("code",{"v-pre":"true"},"Sample text here...\n")],-1),i=t("p",null,"Syntax highlighting",-1),k=t("pre",{class:"code-block language-js"},[t("code",{"v-pre":"true"},[t("span",{class:"token keyword"},"var"),o(),t("span",{class:"token function-variable function"},"foo"),o(),t("span",{class:"token operator"},"="),o(),t("span",{class:"token keyword"},"function"),o(),t("span",{class:"token punctuation"},"("),t("span",{class:"token parameter"},"bar"),t("span",{class:"token punctuation"},")"),o(),t("span",{class:"token punctuation"},"{"),o("\n  "),t("span",{class:"token keyword control-flow"},"return"),o(" bar"),t("span",{class:"token operator"},"++"),t("span",{class:"token punctuation"},";"),o("\n"),t("span",{class:"token punctuation"},"}"),t("span",{class:"token punctuation"},";"),o("\n\n"),t("span",{class:"token console class-name"},"console"),t("span",{class:"token punctuation"},"."),t("span",{class:"token method function property-access"},"log"),t("span",{class:"token punctuation"},"("),t("span",{class:"token function"},"foo"),t("span",{class:"token punctuation"},"("),t("span",{class:"token number"},"5"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),o("\n")])],-1),d=a('<h2 id="tables">Tables</h2><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>data</td><td>path to data files to supply the data that will be passed into templates.</td></tr><tr><td>engine</td><td>engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td>ext</td><td>extension to be used for dest files.</td></tr></tbody></table><p>Right aligned columns</p><table><thead><tr><th style="text-align:right;">Option</th><th style="text-align:right;">Description</th></tr></thead><tbody><tr><td style="text-align:right;">data</td><td style="text-align:right;">path to data files to supply the data that will be passed into templates.</td></tr><tr><td style="text-align:right;">engine</td><td style="text-align:right;">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td style="text-align:right;">ext</td><td style="text-align:right;">extension to be used for dest files.</td></tr></tbody></table><h2 id="links">Links</h2><p><a href="http://dev.nodeca.com" class="external-link" target="_blank" rel="noopener noreferrer">link text</a></p><p><a href="http://nodeca.github.io/pica/demo/" title="title text!" class="external-link" target="_blank" rel="noopener noreferrer">link with title</a></p><p>Autoconverted link <a href="https://github.com/nodeca/pica" class="external-link" target="_blank" rel="noopener noreferrer">https://github.com/nodeca/pica</a> (enable linkify to see)</p><h2 id="images">Images</h2><p><img src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"></p><p>Like links, Images also have a footnote style syntax</p><p><img src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"></p><p>With a reference later in the document defining the URL location:</p><h2 id="plugins">Plugins</h2><p>The killer feature of <code>markdown-it</code> is very effective support of<br><a href="https://www.npmjs.org/browse/keyword/markdown-it-plugin" class="external-link" target="_blank" rel="noopener noreferrer">syntax plugins</a>.</p><h3 id="emojies"><a href="https://github.com/markdown-it/markdown-it-emoji" class="external-link" target="_blank" rel="noopener noreferrer">Emojies</a></h3><blockquote><p>Classic markup: 😉 :crush: 😢 :tear: 😆 😋</p><p>Shortcuts (emoticons): 😃 😦 😎 😉</p></blockquote><p>see <a href="https://github.com/markdown-it/markdown-it-emoji#change-output" class="external-link" target="_blank" rel="noopener noreferrer">how to change output</a> with twemoji.</p><h3 id="subscript-%2F-superscript"><a href="https://github.com/markdown-it/markdown-it-sub" class="external-link" target="_blank" rel="noopener noreferrer">Subscript</a> / <a href="https://github.com/markdown-it/markdown-it-sup" class="external-link" target="_blank" rel="noopener noreferrer">Superscript</a></h3><ul><li>19<sup>th</sup></li><li>H<sub>2</sub>O</li></ul><h3 id="%3Cins%3E"><a href="https://github.com/markdown-it/markdown-it-ins" class="external-link" target="_blank" rel="noopener noreferrer">&lt;ins&gt;</a></h3><p><ins>Inserted text</ins></p><h3 id="%3Cmark%3E"><a href="https://github.com/markdown-it/markdown-it-mark" class="external-link" target="_blank" rel="noopener noreferrer">&lt;mark&gt;</a></h3><p><mark>Marked text</mark></p><h3 id="footnotes"><a href="https://github.com/markdown-it/markdown-it-footnote" class="external-link" target="_blank" rel="noopener noreferrer">Footnotes</a></h3><p>Footnote 1 link<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p><p>Footnote 2 link<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p><p>Inline footnote<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> definition.</p><p>Duplicated footnote reference<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>.</p><h3 id="definition-lists"><a href="https://github.com/markdown-it/markdown-it-deflist" class="external-link" target="_blank" rel="noopener noreferrer">Definition lists</a></h3><dl><dt>Term 1</dt><dd><p>Definition 1<br> with lazy continuation.</p></dd><dt>Term 2 with <em>inline markup</em></dt><dd><p>Definition 2</p><pre><code>  { some code, part of Definition 2 }\n</code></pre><p>Third paragraph of definition 2.</p></dd></dl><p><em>Compact style:</em></p><dl><dt>Term 1</dt><dd>Definition 1</dd><dt>Term 2</dt><dd>Definition 2a</dd><dd>Definition 2b</dd></dl><h3 id="abbreviations"><a href="https://github.com/markdown-it/markdown-it-abbr" class="external-link" target="_blank" rel="noopener noreferrer">Abbreviations</a></h3><p>This is <abbr title="Hyper Text Markup Language">HTML</abbr> abbreviation example.</p><p>It converts “<abbr title="Hyper Text Markup Language">HTML</abbr>”, but keep intact partial entries like “xxxHTMLyyy” and so on.</p><h3 id="custom-containers"><a href="https://github.com/markdown-it/markdown-it-container" class="external-link" target="_blank" rel="noopener noreferrer">Custom containers</a></h3><div class="info"><p>Info Container</p></div><div class="warning"><p>Warning Container</p></div><div class="error"><p>Error Container</p></div><div class="success"><p>Success Container</p></div><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Footnote <strong>can have markup</strong></p><p>and multiple paragraphs.<a href="#fnref1" class="footnote-backref">Go!</a></p></li><li id="fn2" class="footnote-item"><p>Footnote text.<a href="#fnref2" class="footnote-backref">Go!</a><a href="#fnref2:1" class="footnote-backref">Go!</a></p></li><li id="fn3" class="footnote-item"><p>Text of inline footnote<a href="#fnref3" class="footnote-backref">Go!</a></p></li></ol></section>',43);function u(a,t){return n(),s(e,null,[p,l,c,r,i,k,d],64)}const h={render:u,__hmrId:"/home/runner/work/deviltea.me/deviltea.me/posts/markdown-syntax.md"};var g=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",attributes:{title:"Markdown Syntax",description:"支援的 Markdown 語法效果展示",createdDate:"2020/05/01",updatedDate:"2020/05/03"},toc:[{level:"1",content:"h1 Heading &#x1F60E;"},{level:"2",content:"h2 Heading"},{level:"3",content:"h3 Heading"},{level:"4",content:"h4 Heading"},{level:"5",content:"h5 Heading"},{level:"6",content:"h6 Heading"},{level:"2",content:"Horizontal Rules"},{level:"2",content:"Typographic replacements"},{level:"2",content:"Emphasis"},{level:"2",content:"Blockquotes"},{level:"2",content:"Lists"},{level:"2",content:"Code"},{level:"2",content:"Tables"},{level:"2",content:"Links"},{level:"2",content:"Images"},{level:"2",content:"Plugins"},{level:"3",content:'<a href="https://github.com/markdown-it/markdown-it-emoji" class="external-link" target="_blank" rel="noopener noreferrer">Emojies</a>'},{level:"3",content:'<a href="https://github.com/markdown-it/markdown-it-sub" class="external-link" target="_blank" rel="noopener noreferrer">Subscript</a> / <a href="https://github.com/markdown-it/markdown-it-sup" class="external-link" target="_blank" rel="noopener noreferrer">Superscript</a>'},{level:"3",content:'<a href="https://github.com/markdown-it/markdown-it-ins" class="external-link" target="_blank" rel="noopener noreferrer">&lt;ins&gt;</a>'},{level:"3",content:'<a href="https://github.com/markdown-it/markdown-it-mark" class="external-link" target="_blank" rel="noopener noreferrer">&lt;mark&gt;</a>'},{level:"3",content:'<a href="https://github.com/markdown-it/markdown-it-footnote" class="external-link" target="_blank" rel="noopener noreferrer">Footnotes</a>'},{level:"3",content:'<a href="https://github.com/markdown-it/markdown-it-deflist" class="external-link" target="_blank" rel="noopener noreferrer">Definition lists</a>'},{level:"3",content:'<a href="https://github.com/markdown-it/markdown-it-abbr" class="external-link" target="_blank" rel="noopener noreferrer">Abbreviations</a>'},{level:"3",content:'<a href="https://github.com/markdown-it/markdown-it-container" class="external-link" target="_blank" rel="noopener noreferrer">Custom containers</a>'}],VueComponent:h,VueComponentWith:n=>({components:n,render:u})});const m=a('<h2 id="%E5%89%8D%E8%A8%80">前言</h2><p>接續上一篇 <a href="https://deviltea.me/posts/type-challenges" class="external-link" target="_blank" rel="noopener noreferrer">Type Challenges Notes - Easy 篇</a> 後，這次繼續來作答 Medium 難度，由於這個難度的題目數量截至目前有 31 題，所以預計會分個三、四篇來撰寫，那就開始吧</p><h2 id="%E6%9C%AC%E6%96%87">本文</h2><h3 id="medium-1-~-xx">Medium 1 ~ XX</h3><h4 id="get-return-type"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/2-medium-return-type/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Get Return Type</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">MyReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> infer <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">never</span>\n</code></pre></li><li>筆記：<br> 建立條件判斷並利用 <code>infer</code> 來進行返回型態推斷 <code>R</code>，符合條件判斷即返回 <code>R</code>，為配合所有 function 型別，定義參數為 <code>...args: any[]</code></li></ul><h4 id="omit"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/3-medium-omit/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Omit</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">MyOmit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">as</span> <span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">K</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 這邊用到一個沒用過的關鍵字 <code>as</code>，可以看一下官方文件的<a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as" class="external-link" target="_blank" rel="noopener noreferrer">說明</a>，就我的感受上他比較像是可以將 Mapped Type 中的 key 在指定型態的過程中對型別再次轉換，像是答案中定義 key 的步驟 <ol><li>先定義 <code>P</code> 是 keyof <code>T</code></li><li>再約束 <code>P</code> 差集 <code>K</code><br> 最後 value 為 <code>T[P]</code></li></ol></li></ul><h4 id="readonly-2"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/8-medium-readonly-2/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Readonly 2</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">MyReadonly2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">as</span> <span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">K</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 一開始就先約束 <code>K extends keyof T</code>，且可以不提供 <code>K</code> 預設為 <code>keyof T</code>，接下來切成兩部分，第一部分是挑選成為 readonly 的部分，由於一開始我們就已約束 <code>K extends keyof T</code> 於是可以直接寫 <code>readonly [P in K]: T[P];</code>，再來就是類似 <code>Omit</code> 方法去挑選保持原狀的部分，最後將兩部分 <code>&amp;</code> 起來即可</li></ul><h4 id="deep-readonly"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/9-medium-deep-readonly/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Deep Readonly</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span>\n  <span class="token operator">?</span> <span class="token constant">T</span>\n  <span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> DeepReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>\n  <span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 沒有錯啦！型別系統也可以有遞迴（汗，這題就是如果是巢狀型別叫要進去讓最後所有包含的屬性皆為 <code>readonly</code>，遞迴我們都知道有兩個重點，<code>自己呼叫自己</code>、<code>要有終止條件</code>，於是我們先決定出終止條件，<code>keyof T extends never</code> 判斷是否為有 key 要繼續遞迴下去，剩下就是自己呼叫自己的部分。</li></ul><h4 id="tuple-to-union"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/10-medium-tuple-to-union/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Tuple to Union</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">TupleToUnion<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span>\n</code></pre></li><li>筆記：<br> 首先 tuple 應是有序的陣列型態所以先約束 <code>T extends readonly unknown[]</code>，所以返回 <code>T[number]</code> 即可。</li></ul><h4 id="chainable-options"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/12-medium-chainable-options/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Chainable Options</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Chainable<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token generic-function"><span class="token function">option</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token constant">V</span><span class="token punctuation">)</span><span class="token operator">:</span> Chainable<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">V</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>\n  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 刷新觀念的一題，再次感嘆型別系統的靈活性！首先讓 <code>T</code> 預設為 <code>{}</code>，接著重點在於 <code>option</code> 此 method 的型別定義，我們定義他的 generic 為 <code>&lt;K extends string, V&gt;</code>，讓他去自動推斷參數 key 與 value 的型別，令其返回的型別為 <code>Chainable&lt;T &amp; { [P in K]: V }&gt;</code>，就是將目前的 <code>T</code> 與剛傳入的 <code>K</code>、<code>V</code> 組合起來；而 <code>get</code> 就是返回目前傳入的 <code>T</code>。</li></ul><h4 id="last-of-array"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/15-medium-last/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Last of Array</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Last<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token string">&#39;length&#39;</span><span class="token punctuation">]</span><span class="token punctuation">]</span>\n</code></pre></li><li>筆記：<br> 若型別為 tuple (<code>readonly any[]</code>)，則 <code>Array[&#39;length&#39;]</code> 型別就會是具體的數字而不單只是 <code>number</code>，這個做法是利用擴展符號做出長度為 <code>T.length + 1</code> 的 tuple，再利用上述所說的 length 特性來取出最後的元素型別。</li></ul><h4 id="pop"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/16-medium-pop/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Pop</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Pop<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token operator">...</span>infer <span class="token constant">R</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">never</span>\n</code></pre></li><li>筆記：<br> 這題利用擴展符號配合 <code>infer</code> 來推斷出排除最後一個元素後剩下部分 tuple。</li></ul><h4 id="promise.all"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/20-medium-promise-all/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Promise.all</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">PromiseAll</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>values<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span>\n  <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span>infer <span class="token constant">R</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span>\n</code></pre></li><li>筆記：<br> 這題卡住了一陣子，最後參考了他人的<a href="https://github.com/type-challenges/type-challenges/issues/211" class="external-link" target="_blank" rel="noopener noreferrer">解答</a>，仍然是似懂非懂，需要再做更深的理解。</li></ul><h4 id="type-lookup"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/62-medium-type-lookup/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Type Lookup</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">LookUp<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> <span class="token keyword">type</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span>\n<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span>\n</code></pre></li><li>筆記：<br> 先令 <code>T</code> 為 string，使 <code>T</code> 可為 Mapped Type 所用，接著定義一個 Mapped Type，<code>K</code> 於 <code>T</code> 之中，約束 <code>U</code> 需繼承 <code>{ type: T }</code>，此時已經將 <code>U</code> 的聯集分離了，最後再直接以 <code>[T]</code> 來返回分離後型別。</li></ul><h2 id="%E5%BE%8C%E8%A8%98">後記</h2><p>進入到 Medium 的階段後，難度真的是大幅提升啊（汗，有很多的觀念有待釐清，還有一題日後再來補充。</p>',26);function b(n,s){return m}const y={render:b,__hmrId:"/home/runner/work/deviltea.me/deviltea.me/posts/type-challenges-2.md"};var f=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",attributes:{title:"Type Challenges Notes - Medium 篇（一）",description:"練習作答 Type Challenges Medium 難度的第一部分",createdDate:"2021/05/11"},toc:[{level:"2",content:"&#x524D;&#x8A00;"},{level:"2",content:"&#x672C;&#x6587;"},{level:"3",content:"Medium 1 ~ XX"},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/2-medium-return-type/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Get Return Type</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/3-medium-omit/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Omit</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/8-medium-readonly-2/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Readonly 2</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/9-medium-deep-readonly/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Deep Readonly</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/10-medium-tuple-to-union/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Tuple to Union</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/12-medium-chainable-options/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Chainable Options</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/15-medium-last/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Last of Array</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/16-medium-pop/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Pop</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/20-medium-promise-all/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Promise.all</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/62-medium-type-lookup/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Type Lookup</a>'},{level:"2",content:"&#x5F8C;&#x8A18;"}],VueComponent:y,VueComponentWith:n=>({components:n,render:b})});const w=a('<h2 id="%E5%89%8D%E8%A8%80">前言</h2><p>這是一篇關於 <a href="https://tsch.js.org/" class="external-link" target="_blank" rel="noopener noreferrer">Type Challenges</a> 作答時的一些筆記，「Type Challenges」 是什麼呢？有鑒於 TS 在前端世界裡越來越盛行，似乎已成為熱門必備技能，而 TS 中的型別系統也是日益完備與強大，除了基本的使用 type / interface 已經讓我嗅到了不足的味道，是時候來腳踏實地的練習運用 TS 型別系統了！</p><h2 id="%E6%9C%AC%E6%96%87">本文</h2><p>在 Type Challenges 該 Repo 中的 README 中就有提供一份由難易度分類的<a href="https://github.com/type-challenges/type-challenges/blob/master/README.md#challenges" class="external-link" target="_blank" rel="noopener noreferrer">清單</a>可供挑戰，並且作答時會有建立好的 TS Playground 使用，也有 github issues 中的其他參與者答案可以參考學習，可謂是非常貼心！</p><h3 id="easy">Easy</h3><h4 id="pick"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/4-easy-pick/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Pick</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">MyPick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 首先約束 <code>K</code> 須為 <code>T</code> 的 key，接著定義 Mapped Type 令 key <code>P</code> 在 <code>K</code> 之中且 value 為 <code>T[P]</code></li></ul><h4 id="readonly"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/7-easy-readonly/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Readonly</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">MyReadonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 定義 Mapped Type，先加上 readonly，令 key <code>K</code> 為 keyof <code>T</code>，value 為 <code>T[K]</code></li></ul><h4 id="tuple-to-object"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/11-easy-tuple-to-object/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Tuple to Object</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">TupleToObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></li><li>筆記：<br> 由於 <code>T</code> 為唯讀的陣列因此可推斷為 TS 中的 tuple，這就代表 <code>T[number]</code> 是可以推斷對應的值，所以令 Mapped Type 的 key 為 <code>K</code> 並存在於 <code>T[number]</code> 之中，且令 value 為 <code>K</code></li></ul><h4 id="first-of-array"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/14-easy-first/README.md" class="external-link" target="_blank" rel="noopener noreferrer">First of Array</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">First<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span>\n  <span class="token operator">?</span> <span class="token builtin">never</span>\n  <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>\n</code></pre></li><li>筆記：<br> 先約束若 <code>T[number]</code> 為 never，即陣列為空應返回 <code>never</code>，否則返回 <code>T[0]</code></li></ul><h4 id="length-of-tuple"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/18-easy-tuple-length/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Length of Tuple</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Length<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token string">&#39;length&#39;</span><span class="token punctuation">]</span>\n</code></pre></li><li>筆記：<br> 讓 <code>T</code> 限制為唯讀 <code>any[]</code>，讓型別推斷可推斷出 <code>T[&#39;lemgth&#39;]</code></li></ul><h4 id="exclude"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/43-easy-exclude/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Exclude</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">MyExclude<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span>\n</code></pre></li><li>筆記：<br> 若 <code>T</code> 包含於 <code>U</code>，返回 <code>never</code> 否則返回 <code>T</code></li></ul><h4 id="awaited"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/189-easy-awaited/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Awaited</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Awaited<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span>infer <span class="token constant">T</span><span class="token operator">&gt;</span></span>\n  <span class="token operator">?</span> <span class="token constant">T</span>\n  <span class="token operator">:</span> <span class="token builtin">never</span>\n</code></pre></li><li>筆記：<br> 使用 <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types" class="external-link" target="_blank" rel="noopener noreferrer">infer</a> 在條件式保持推斷，在這題用來判斷型別是否繼承 <code>Promise</code> 並推斷 <code>Promise&lt;T&gt;</code> 的 <code>T</code> 應該為什麽型別</li></ul><h4 id="if"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/268-easy-if/README.md" class="external-link" target="_blank" rel="noopener noreferrer">If</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">If<span class="token operator">&lt;</span><span class="token constant">C</span> <span class="token keyword">extends</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">F</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">C</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token constant">F</span>\n</code></pre></li><li>筆記：<br> 先約束 <code>C</code> 為 <code>boolean</code> 及非 <code>true</code> 則 <code>false</code>，後面就簡單了，<code>C</code> 為 <code>true</code> 返回 <code>T</code>，反之為 <code>F</code></li></ul><h4 id="concat"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/533-easy-concat/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Concat</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Concat<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token constant">U</span><span class="token punctuation">]</span>\n</code></pre></li><li>筆記：<br> 約束 <code>T</code>、<code>U</code> 為 array / tuple，就可以使用概念接近擴展符號的方法去串起 <code>T</code>、<code>U</code> 所有型別</li></ul><h4 id="includes"><a href="https://github.com/type-challenges/type-challenges/blob/master/questions/898-easy-includes/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Includes</a></h4><ul><li>答案：<pre class="code-block language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Includes<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">T</span></span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n</code></pre></li><li>筆記：<br><code>T</code> 被約束為 <code>readonly any[]</code> (tuple)，利用此點可進行 <code>U extends T[number]</code> 條件推斷</li></ul><h2 id="%E5%BE%8C%E8%A8%98">後記</h2><p>在這篇先整理跟作答完 <code>Easy</code> 難度的所有題目，對於原本只會使用基礎型別的我來說算是滿不錯的暖身練習，也算是基本的摸了摸 <code>Mapped Type</code>、<code>Conditional Type</code> 等等的知識，截至為止也做了一部分的 <code>Medium</code> 難度的題目，難度一下就提了上來（汗，不過也讓我刷新眼界，TS 的型別系統真的很酷 😄</p>',27);function x(n,s){return w}const T={render:x,__hmrId:"/home/runner/work/deviltea.me/deviltea.me/posts/type-challenges.md"};var E=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",attributes:{title:"Type Challenges Notes - Easy 篇",description:"練習作答 Type Challenges 的一些筆記，Easy 難度的部分",createdDate:"2021/05/10"},toc:[{level:"2",content:"&#x524D;&#x8A00;"},{level:"2",content:"&#x672C;&#x6587;"},{level:"3",content:"Easy"},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/4-easy-pick/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Pick</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/7-easy-readonly/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Readonly</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/11-easy-tuple-to-object/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Tuple to Object</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/14-easy-first/README.md" class="external-link" target="_blank" rel="noopener noreferrer">First of Array</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/18-easy-tuple-length/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Length of Tuple</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/43-easy-exclude/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Exclude</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/189-easy-awaited/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Awaited</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/268-easy-if/README.md" class="external-link" target="_blank" rel="noopener noreferrer">If</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/533-easy-concat/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Concat</a>'},{level:"4",content:'<a href="https://github.com/type-challenges/type-challenges/blob/master/questions/898-easy-includes/README.md" class="external-link" target="_blank" rel="noopener noreferrer">Includes</a>'},{level:"2",content:"&#x5F8C;&#x8A18;"}],VueComponent:T,VueComponentWith:n=>({components:n,render:x})});export{g as _,f as a,E as b};
